#!/bin/bash

# Pactopus Simple Package Installer
# Supports: Arch Linux, Fedora, Ubuntu
# Usage: ./simple-install.sh [package-set1] [package-set2] ...

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_FILE="$SCRIPT_DIR/packages.conf"

# Parse package sets from config file
parse_package_sets() {
    local current_set=""
    local -A package_sets
    
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        
        # Check for package set definition
        if [[ "$line" =~ ^\[PACKAGE_SET:([^]]+)\]$ ]]; then
            current_set="${BASH_REMATCH[1]}"
            package_sets["$current_set"]=""
        # Check for package definition (end of package sets)
        elif [[ "$line" =~ ^\[PACKAGE: ]]; then
            break
        # Add package to current set
        elif [[ -n "$current_set" ]]; then
            if [[ "$line" =~ ^@(.+)$ ]]; then
                # Reference to another package set
                local ref_set="${BASH_REMATCH[1]}"
                package_sets["$current_set"]+="@$ref_set "
            else
                # Regular package
                package_sets["$current_set"]+="$line "
            fi
        fi
    done < "$CONFIG_FILE"
    
    # Export package sets as global variables (replace hyphens with underscores for valid variable names)
    for set_name in "${!package_sets[@]}"; do
        local var_name="PACKAGE_SET_${set_name//-/_}"
        declare -g "$var_name"="${package_sets[$set_name]}"
    done
}

# Get available package sets from config
get_available_package_sets() {
    local sets=()
    while IFS= read -r line; do
        if [[ "$line" =~ ^\[PACKAGE_SET:([^]]+)\]$ ]]; then
            sets+=("${BASH_REMATCH[1]}")
        fi
    done < "$CONFIG_FILE"
    printf '%s\n' "${sets[@]}"
}

# Get packages for a specific package set (with reference resolution)
get_package_set_packages() {
    local set_name="$1"
    local -A visited_sets
    local packages=""
    
    _resolve_package_set() {
        local current_set="$1"
        
        # Prevent infinite recursion
        if [[ -n "${visited_sets[$current_set]}" ]]; then
            return
        fi
        visited_sets["$current_set"]=1
        
        local var_name="PACKAGE_SET_${current_set//-/_}"
        local set_packages="${!var_name}"
        
        for pkg in $set_packages; do
            if [[ "$pkg" =~ ^@(.+)$ ]]; then
                # Resolve reference to another package set
                _resolve_package_set "${BASH_REMATCH[1]}"
            else
                # Add regular package
                packages+="$pkg "
            fi
        done
    }
    
    _resolve_package_set "$set_name"
    echo "$packages"
}

# Detect distribution
detect_distro() {
    if command -v pacman &> /dev/null; then
        echo "arch"
    elif command -v dnf &> /dev/null; then
        echo "fedora"
    elif command -v apt &> /dev/null; then
        echo "ubuntu"
    else
        echo "Unsupported distribution" >&2
        exit 1
    fi
}

# Get package name for specific distribution
get_package_name() {
    local package="$1"
    local distro="$2"
    
    # Look for package definition in config file
    local line
    line=$(grep "^\[PACKAGE:$package:" "$CONFIG_FILE" 2>/dev/null || echo "")
    
    if [[ -z "$line" ]]; then
        echo "$package"  # Default to package name if not found
        return
    fi
    
    # Parse the package definition: [PACKAGE:name:arch:fedora:ubuntu]
    if [[ "$line" =~ ^\[PACKAGE:([^:]+):([^:]+):([^:]+):([^]]+)\]$ ]]; then
        case "$distro" in
            arch)
                echo "${BASH_REMATCH[2]}"
                ;;
            fedora)
                echo "${BASH_REMATCH[3]}"
                ;;
            ubuntu)
                echo "${BASH_REMATCH[4]}"
                ;;
        esac
    else
        echo "$package"  # Fallback
    fi
}

# Install a single package
install_package() {
    local package="$1"
    local distro="$2"
    local pkg_name
    
    pkg_name=$(get_package_name "$package" "$distro")
    
    if [ "$pkg_name" = "SKIP" ]; then
        echo "Skipping $package (not available on $distro)"
        return
    fi
    
    if [ "$pkg_name" = "SPECIAL" ]; then
        install_special_package "$package" "$distro"
        return
    fi
    
    echo "Installing: $package ($pkg_name)"
    
    case "$distro" in
        arch)
            if ! pacman -Qi "$pkg_name" &> /dev/null; then
                sudo pacman -S --noconfirm "$pkg_name" || echo "Warning: Failed to install $pkg_name"
            else
                echo "$pkg_name already installed"
            fi
            ;;
        fedora)
            if ! rpm -q "$pkg_name" &> /dev/null; then
                sudo dnf install -y "$pkg_name" || echo "Warning: Failed to install $pkg_name"
            else
                echo "$pkg_name already installed"
            fi
            ;;
        ubuntu)
            if ! dpkg -l | grep -q "^ii  $pkg_name "; then
                sudo apt install -y "$pkg_name" || echo "Warning: Failed to install $pkg_name"
            else
                echo "$pkg_name already installed"
            fi
            ;;
    esac
}

# Handle special package installations
install_special_package() {
    local package="$1"
    local distro="$2"
    
    case "$package" in
        starship)
            if ! command -v starship &> /dev/null; then
                echo "Installing Starship prompt..."
                curl -sS https://starship.rs/install.sh | sh -s -- -y
            else
                echo "Starship already installed"
            fi
            ;;
        xh)
            if ! command -v xh &> /dev/null; then
                case "$distro" in
                    ubuntu)
                        if command -v snap &> /dev/null; then
                            sudo snap install xh
                        else
                            echo "Warning: xh requires snap on Ubuntu"
                        fi
                        ;;
                esac
            else
                echo "xh already installed"
            fi
            ;;
        ble.sh)
            if [ ! -d "$HOME/.local/share/blesh" ]; then
                echo "Installing ble.sh..."
                git clone --recursive https://github.com/akinomyoga/ble.sh.git /tmp/ble.sh
                make -C /tmp/ble.sh install PREFIX="$HOME/.local"
                rm -rf /tmp/ble.sh
            else
                echo "ble.sh already installed"
            fi
            ;;
        nvm)
            if [ ! -d "$HOME/.nvm" ]; then
                echo "Installing NVM..."
                curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
            else
                echo "NVM already installed"
            fi
            ;;
        aws-cli)
            if ! command -v aws &> /dev/null; then
                echo "Installing AWS CLI..."
                case "$distro" in
                    arch)
                        if command -v yay &> /dev/null; then
                            echo "Installing AWS CLI from AUR using yay..."
                            yay -S --noconfirm aws-cli-v2
                        else
                            echo "Warning: yay not found. Installing AWS CLI manually..."
                            # Fallback to manual installation
                            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                            unzip awscliv2.zip
                            sudo ./aws/install
                            rm -rf aws awscliv2.zip
                        fi
                        ;;
                    ubuntu)
                        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                        unzip awscliv2.zip
                        sudo ./aws/install
                        rm -rf aws awscliv2.zip
                        ;;
                esac
            else
                echo "AWS CLI already installed"
            fi
            ;;
        azure-cli)
            if ! command -v az &> /dev/null; then
                echo "Installing Azure CLI..."
                case "$distro" in
                    ubuntu)
                        curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
                        ;;
                    *)
                        echo "Note: Azure CLI installation varies by distribution"
                        ;;
                esac
            else
                echo "Azure CLI already installed"
            fi
            ;;
        fastfetch)
            if ! command -v fastfetch &> /dev/null; then
                case "$distro" in
                    ubuntu)
                        # Install from GitHub releases for Ubuntu
                        echo "Installing fastfetch from GitHub..."
                        wget -O /tmp/fastfetch.deb "https://github.com/fastfetch-cli/fastfetch/releases/latest/download/fastfetch-linux-amd64.deb"
                        sudo dpkg -i /tmp/fastfetch.deb || sudo apt-get install -f -y
                        rm /tmp/fastfetch.deb
                        ;;
                esac
            else
                echo "fastfetch already installed"
            fi
            ;;
        brave-browser)
            if ! command -v brave-browser &> /dev/null; then
                echo "Installing Brave Browser..."
                case "$distro" in
                    ubuntu)
                        curl -fsSLo /usr/share/keyrings/brave-browser-archive-keyring.gpg https://brave-browser-apt-release.s3.brave.com/brave-browser-archive-keyring.gpg
                        echo "deb [signed-by=/usr/share/keyrings/brave-browser-archive-keyring.gpg] https://brave-browser-apt-release.s3.brave.com/ stable main" | sudo tee /etc/apt/sources.list.d/brave-browser-release.list
                        sudo apt update
                        sudo apt install -y brave-browser
                        ;;
                    *)
                        echo "Note: Brave Browser installation varies by distribution"
                        ;;
                esac
            else
                echo "Brave Browser already installed"
            fi
            ;;
        yay)
            if ! command -v yay &> /dev/null; then
                case "$distro" in
                    arch)
                        echo "Installing yay AUR helper..."
                        # Install base-devel if not already installed
                        sudo pacman -S --needed --noconfirm base-devel git
                        # Clone yay from AUR
                        cd /tmp
                        git clone https://aur.archlinux.org/yay.git
                        cd yay
                        makepkg -si --noconfirm
                        cd /
                        rm -rf /tmp/yay
                        ;;
                    *)
                        echo "yay is only available on Arch Linux"
                        ;;
                esac
            else
                echo "yay already installed"
            fi
            ;;
        *)
            echo "Unknown special package: $package"
            ;;
    esac
}

# Update package databases
update_system() {
    local distro="$1"
    
    echo "Updating package databases..."
    case "$distro" in
        arch)
            sudo pacman -Sy
            ;;
        fedora)
            sudo dnf check-update || true
            ;;
        ubuntu)
            sudo apt update
            ;;
    esac
}

# Define package sets
install_package_set() {
    local set_name="$1"
    local distro="$2"
    
    # Get packages for this set from config
    local packages
    packages=$(get_package_set_packages "$set_name")
    
    if [[ -z "$packages" ]]; then
        echo "Internal error: No packages found for set: $set_name" >&2
        return 1
    fi
    
    # Install each package
    for package in $packages; do
        install_package "$package" "$distro"
    done
}

# Normalize package set name (convert shortened names to full names)
normalize_package_set_name() {
    local set_name="$1"
    
    case "$set_name" in
        # Full names (already normalized)
        server-packages|cloud-packages|development-packages|basic-workstation|full-workstation|gnome-packages|hyprland-packages)
            echo "$set_name"
            ;;
        # Shortened names (add -packages suffix)
        server)
            echo "server-packages"
            ;;
        cloud)
            echo "cloud-packages"
            ;;
        development|dev)
            echo "development-packages"
            ;;
        gnome)
            echo "gnome-packages"
            ;;
        hyprland)
            echo "hyprland-packages"
            ;;
        # Special cases that don't follow the pattern
        basic-workstation|basic)
            echo "basic-workstation"
            ;;
        full-workstation|full)
            echo "full-workstation"
            ;;
        *)
            echo "$set_name"  # Return as-is if no normalization rule
            ;;
    esac
}

# Validate package set name
validate_package_set() {
    local set_name="$1"
    local normalized_name
    
    normalized_name=$(normalize_package_set_name "$set_name")
    
    # Check if the normalized name exists in available package sets
    local available_sets
    available_sets=$(get_available_package_sets)
    
    while IFS= read -r available_set; do
        if [[ "$normalized_name" == "$available_set" ]]; then
            return 0
        fi
    done <<< "$available_sets"
    
    return 1
}

# Validate all requested package sets before installation
validate_all_package_sets() {
    local invalid_sets=()
    
    for package_set in "$@"; do
        if ! validate_package_set "$package_set"; then
            invalid_sets+=("$package_set")
        fi
    done
    
    if [ ${#invalid_sets[@]} -gt 0 ]; then
        echo "Error: Unknown package set(s): ${invalid_sets[*]}" >&2
        echo "" >&2
        echo "Available package sets:" >&2
        
        # Dynamically show available package sets with shortened names
        local available_sets
        available_sets=$(get_available_package_sets)
        while IFS= read -r set_name; do
            local short_names=""
            case "$set_name" in
                server-packages) short_names=" (or: server)" ;;
                cloud-packages) short_names=" (or: cloud)" ;;
                development-packages) short_names=" (or: development, dev)" ;;
                basic-workstation) short_names=" (or: basic)" ;;
                full-workstation) short_names=" (or: full)" ;;
                gnome-packages) short_names=" (or: gnome)" ;;
                hyprland-packages) short_names=" (or: hyprland)" ;;
            esac
            echo "  $set_name$short_names" >&2
        done <<< "$available_sets"
        
        return 1
    fi
    
    return 0
}

# Main script
main() {
    local distro
    distro=$(detect_distro)
    
    echo "Detected distribution: $distro"
    
    # Parse package sets from config file
    parse_package_sets
    
    if [ $# -eq 0 ]; then
        echo "Usage: $0 [package-set1] [package-set2] ..."
        echo "Available package sets:"
        
        # Dynamically show available package sets
        local available_sets
        available_sets=$(get_available_package_sets)
        while IFS= read -r set_name; do
            local short_names=""
            case "$set_name" in
                server-packages) short_names=" (or: server)" ;;
                cloud-packages) short_names=" (or: cloud)" ;;
                development-packages) short_names=" (or: development, dev)" ;;
                basic-workstation) short_names=" (or: basic)" ;;
                full-workstation) short_names=" (or: full)" ;;
                gnome-packages) short_names=" (or: gnome)" ;;
                hyprland-packages) short_names=" (or: hyprland)" ;;
            esac
            echo "  $set_name$short_names"
        done <<< "$available_sets"
        
        exit 1
    fi
    
    # Validate all package sets before starting installation
    if ! validate_all_package_sets "$@"; then
        exit 1
    fi
    
    # Normalize package set names
    local normalized_sets=()
    for package_set in "$@"; do
        normalized_sets+=($(normalize_package_set_name "$package_set"))
    done
    
    echo "Validated package sets: ${normalized_sets[*]}"
    echo ""
    
    update_system "$distro"
    
    for package_set in "${normalized_sets[@]}"; do
        echo "Installing package set: $package_set"
        install_package_set "$package_set" "$distro"
    done
    
    echo "Installation complete!"
}

main "$@"
