#!/bin/bash

# Pactopus - Simple Package Manager for Fedora
# Version: 2.0.0

# Removed set -e to allow continuing on individual failures

# Configuration
CONFIG_DIR="$HOME/.local/etc/pactopus"
CONFIG_FILE="$CONFIG_DIR/packages.conf"
GNOME_CONFIG_FILE="$CONFIG_DIR/gnome-packages.conf"
GNOME_EXTENSIONS_FILE="$CONFIG_DIR/gnome-extensions.conf"
STATE_DIR="$HOME/.config/pactopus"
STATE_FILE="$STATE_DIR/state.conf"
DOTFILES_DIR="$HOME/source/dotfiles"
DOTFILES_REPO="https://github.com/jdubba/dotfiles.git"
UTILITIES_DIR="$HOME/source/utilities"
UTILITIES_REPO="https://github.com/jdubba/utilities.git"

# Logging configuration
LOG_DIR="$HOME/.local/var"
LOG_FILE="$LOG_DIR/pactopus.log"
LOG_FILE_OLD="$LOG_DIR/pactopus.log.old"
MAX_LOG_SIZE=$((25 * 1024 * 1024))  # 25 MiB in bytes

# Installation tracking arrays
declare -a SUCCESSFUL_INSTALLS=()
declare -a FAILED_INSTALLS=()
declare -a SKIPPED_INSTALLS=()

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Initialize logging
init_logging() {
    # Create log directory if it doesn't exist
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
    fi
    
    # Rotate log if it exceeds max size
    rotate_log_if_needed
    
    # Log initial session start
    log_entry "INFO" "Pactopus session started"
    log_entry "INFO" "Command: pactopus $*"
}

# Get current timestamp
get_timestamp() {
    date '+%Y-%m-%d %H:%M:%S'
}

# Rotate log file if it exceeds max size
rotate_log_if_needed() {
    if [[ -f "$LOG_FILE" ]]; then
        local log_size
        log_size=$(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null || echo 0)
        
        if [[ $log_size -gt $MAX_LOG_SIZE ]]; then
            # Move current log to .old (overwriting any existing .old file)
            mv -f "$LOG_FILE" "$LOG_FILE_OLD"
            
            # Log rotation event in new log file
            echo "[$(get_timestamp)] [INFO] Log rotated - previous log moved to $LOG_FILE_OLD" >> "$LOG_FILE"
        fi
    fi
}

# Write log entry
log_entry() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp=$(get_timestamp)
    
    # Ensure log directory exists
    [[ -d "$LOG_DIR" ]] || mkdir -p "$LOG_DIR"
    
    # Write to log file
    echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    
    # Check if rotation is needed after write
    rotate_log_if_needed
}

# Log command execution
log_command() {
    local command="$1"
    local status="$2"
    
    if [[ -n "$status" ]]; then
        log_entry "CMD" "Command executed: $command (status: $status)"
    else
        log_entry "CMD" "Executing command: $command"
    fi
}

# Print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
    log_entry "INFO" "$1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
    log_entry "SUCCESS" "$1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
    log_entry "WARNING" "$1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
    log_entry "ERROR" "$1"
}

# Track installation results
track_success() {
    local package="$1"
    SUCCESSFUL_INSTALLS+=("$package")
    log_entry "TRACK" "Package marked as successful: $package"
}

track_failure() {
    local package="$1"
    local reason="${2:-Unknown error}"
    FAILED_INSTALLS+=("$package: $reason")
    log_entry "TRACK" "Package marked as failed: $package - Reason: $reason"
}

track_skipped() {
    local package="$1"
    local reason="${2:-Already installed}"
    SKIPPED_INSTALLS+=("$package: $reason")
    log_entry "TRACK" "Package marked as skipped: $package - Reason: $reason"
}

# Print installation summary
print_summary() {
    echo ""
    echo -e "${BLUE}============================================${NC}"
    echo -e "${BLUE}        INSTALLATION SUMMARY${NC}"
    echo -e "${BLUE}============================================${NC}"
    echo ""
    
    local total=$((${#SUCCESSFUL_INSTALLS[@]} + ${#FAILED_INSTALLS[@]} + ${#SKIPPED_INSTALLS[@]}))
    
    echo -e "Total packages processed: ${total}"
    echo -e "${GREEN}✓ Successful: ${#SUCCESSFUL_INSTALLS[@]}${NC}"
    echo -e "${YELLOW}⊝ Skipped: ${#SKIPPED_INSTALLS[@]}${NC}"
    echo -e "${RED}✗ Failed: ${#FAILED_INSTALLS[@]}${NC}"
    echo ""
    
    if [[ ${#SUCCESSFUL_INSTALLS[@]} -gt 0 ]]; then
        echo -e "${GREEN}Successfully installed:${NC}"
        for item in "${SUCCESSFUL_INSTALLS[@]}"; do
            echo "  ✓ $item"
        done
        echo ""
    fi
    
    if [[ ${#SKIPPED_INSTALLS[@]} -gt 0 ]]; then
        echo -e "${YELLOW}Skipped packages:${NC}"
        for item in "${SKIPPED_INSTALLS[@]}"; do
            echo "  ⊝ $item"
        done
        echo ""
    fi
    
    if [[ ${#FAILED_INSTALLS[@]} -gt 0 ]]; then
        echo -e "${RED}Failed installations:${NC}"
        for item in "${FAILED_INSTALLS[@]}"; do
            echo "  ✗ $item"
        done
        echo ""
        echo -e "${YELLOW}Please review the failed installations above and try again manually if needed.${NC}"
    else
        echo -e "${GREEN}All installations completed successfully!${NC}"
    fi
    
    echo -e "${BLUE}============================================${NC}"
}

# Ensure we're running on Fedora
check_system() {
    if ! command -v dnf &> /dev/null; then
        print_error "This tool requires Fedora with dnf package manager"
        exit 1
    fi
    
    if [[ ! -f /etc/fedora-release ]]; then
        print_warning "This tool is designed for Fedora. Proceed with caution."
    fi
    
    # Check for config files
    if [[ ! -f "$CONFIG_FILE" ]]; then
        print_error "Configuration file not found: $CONFIG_FILE"
        print_error "Please run 'make install' from the pactopus source directory first"
        exit 1
    fi
}

# Detect if running in GNOME environment
is_gnome_environment() {
    # Check for GNOME session
    if [[ "$XDG_CURRENT_DESKTOP" == *"GNOME"* ]] || \
       [[ "$DESKTOP_SESSION" == *"gnome"* ]] || \
       [[ "$XDG_SESSION_DESKTOP" == *"gnome"* ]]; then
        return 0
    fi
    
    # Check if gnome-shell is running
    if pgrep -x "gnome-shell" > /dev/null 2>&1; then
        return 0
    fi
    
    return 1
}

# Parse packages from config file
get_packages() {
    local packages=()
    local special_packages=()
    
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        
        # Check if it's a special package
        if [[ "$line" =~ ^([^#]+)#[[:space:]]*SPECIAL ]]; then
            package="${BASH_REMATCH[1]}"
            package="${package%% *}"  # Trim trailing spaces
            special_packages+=("$package")
        else
            # Regular package
            package="${line%% *}"  # Get first word, trim trailing spaces
            packages+=("$package")
        fi
    done < "$CONFIG_FILE"
    
    echo "REGULAR:${packages[*]}"
    echo "SPECIAL:${special_packages[*]}"
}

# Parse GNOME packages from config file
get_gnome_packages() {
    local packages=()
    local special_packages=()
    
    # Only process if GNOME config file exists
    if [[ ! -f "$GNOME_CONFIG_FILE" ]]; then
        return 0
    fi
    
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        
        # Check if it's a special package
        if [[ "$line" =~ ^([^#]+)#[[:space:]]*SPECIAL ]]; then
            package="${BASH_REMATCH[1]}"
            package="${package%% *}"  # Trim trailing spaces
            special_packages+=("$package")
        else
            # Regular package
            package="${line%% *}"  # Get first word, trim trailing spaces
            packages+=("$package")
        fi
    done < "$GNOME_CONFIG_FILE"
    
    echo "REGULAR:${packages[*]}"
    echo "SPECIAL:${special_packages[*]}"
}

# Parse GNOME extensions from config file
get_gnome_extensions() {
    local extensions=()
    
    # Only process if GNOME extensions config file exists
    if [[ ! -f "$GNOME_EXTENSIONS_FILE" ]]; then
        return 0
    fi
    
    while IFS= read -r line; do
        # Skip comments and empty lines
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        
        # Extract extension info (format: uuid|id|name)
        extensions+=("$line")
    done < "$GNOME_EXTENSIONS_FILE"
    
    printf '%s\n' "${extensions[@]}"
}

# Install GNOME Shell extension
install_gnome_extension() {
    local extension_info="$1"
    
    # Parse extension info
    IFS='|' read -r uuid extension_id name <<< "$extension_info"
    
    # Check if extension is already installed
    if [[ -d "$HOME/.local/share/gnome-shell/extensions/$uuid" ]]; then
        print_info "$name already installed"
        track_skipped "$name" "Already installed"
        
        # Check if extension is enabled
        if gnome-extensions list --enabled 2>/dev/null | grep -q "$uuid"; then
            print_info "$name is already enabled"
        else
            print_info "Enabling previously installed extension: $name..."
            log_command "gnome-extensions enable $uuid"
            if gnome-extensions enable "$uuid" 2>/dev/null; then
                log_command "gnome-extensions enable $uuid" "success"
                print_success "$name enabled successfully"
            else
                log_command "gnome-extensions enable $uuid" "failed"
                print_warning "Failed to enable $name. You can enable it manually using GNOME Extensions app"
            fi
        fi
        return 0
    fi
    
    print_info "Installing GNOME extension: $name..."
    
    # Get GNOME Shell version
    GNOME_VERSION=$(gnome-shell --version | grep -oP '\d+\.\d+' | head -1)
    if [[ -z "$GNOME_VERSION" ]]; then
        track_failure "$name" "Unable to determine GNOME Shell version"
        print_error "Unable to determine GNOME Shell version"
        return 1
    fi
    
    # Create extensions directory if it doesn't exist
    mkdir -p "$HOME/.local/share/gnome-shell/extensions"
    
    # Download extension metadata
    TEMP_DIR=$(mktemp -d)
    (
        cd "$TEMP_DIR"
        
        # Get extension info from GNOME extensions API
        API_URL="https://extensions.gnome.org/extension-info/?pk=$extension_id&shell_version=$GNOME_VERSION"
        
        if ! curl -s "$API_URL" -o extension_info.json 2>/dev/null; then
            track_failure "$name" "Failed to fetch extension info from API"
            print_error "Failed to fetch extension info for $name"
            cd - > /dev/null
            rm -rf "$TEMP_DIR"
            return 1
        fi
        
        # Check if extension supports this GNOME version
        if grep -q '"error"' extension_info.json 2>/dev/null; then
            track_failure "$name" "Extension doesn't support GNOME Shell $GNOME_VERSION"
            print_error "$name doesn't support GNOME Shell $GNOME_VERSION"
            cd - > /dev/null
            rm -rf "$TEMP_DIR"
            return 1
        fi
        
        # Get download URL
        DOWNLOAD_URL=$(grep -oP '"download_url"\s*:\s*"[^"]+' extension_info.json | cut -d'"' -f4)
        
        if [[ -z "$DOWNLOAD_URL" ]]; then
            track_failure "$name" "Failed to get download URL"
            print_error "Failed to get download URL for $name"
            cd - > /dev/null
            rm -rf "$TEMP_DIR"
            return 1
        fi
        
        # Download and extract extension
        if curl -L "https://extensions.gnome.org$DOWNLOAD_URL" -o extension.zip 2>/dev/null && \
           unzip -q extension.zip -d "$HOME/.local/share/gnome-shell/extensions/$uuid" 2>/dev/null; then
            track_success "$name"
            print_success "$name installed successfully"
            
            # Enable the extension
            print_info "Enabling extension: $name..."
            log_command "gnome-extensions enable $uuid"
            if gnome-extensions enable "$uuid" 2>/dev/null; then
                log_command "gnome-extensions enable $uuid" "success"
                print_success "$name enabled successfully"
            else
                log_command "gnome-extensions enable $uuid" "failed"
                print_warning "Failed to enable $name automatically. You can enable it manually using GNOME Extensions app"
            fi
        else
            track_failure "$name" "Failed to download or extract extension"
            print_error "Failed to install $name"
        fi
    )
    cd - > /dev/null
    rm -rf "$TEMP_DIR"
}

# Install all GNOME extensions
install_gnome_extensions() {
    if ! is_gnome_environment; then
        return 0
    fi
    
    # Check if gnome-extensions tool is available
    if ! command -v gnome-extensions &> /dev/null; then
        print_warning "gnome-extensions command not found. Install gnome-shell to manage extensions."
        return 0
    fi
    
    print_info "Installing GNOME Shell extensions..."
    
    # Get list of extensions
    mapfile -t extensions < <(get_gnome_extensions)
    
    if [[ ${#extensions[@]} -eq 0 ]]; then
        print_info "No GNOME extensions configured"
        return 0
    fi
    
    for extension in "${extensions[@]}"; do
        install_gnome_extension "$extension"
    done
}

# Install special packages with custom methods
install_special_package() {
    local package="$1"
    
    case "$package" in
        starship)
            if ! command -v starship &> /dev/null; then
                print_info "Installing Starship prompt..."
                log_command "curl -sS https://starship.rs/install.sh | sh -s -- -y"
                if curl -sS https://starship.rs/install.sh | sh -s -- -y 2>/dev/null; then
                    log_command "curl -sS https://starship.rs/install.sh | sh -s -- -y" "success"
                    track_success "$package"
                    print_success "Starship installed successfully"
                else
                    log_command "curl -sS https://starship.rs/install.sh | sh -s -- -y" "failed"
                    track_failure "$package" "Failed to download or install Starship"
                    print_error "Failed to install Starship"
                fi
            else
                print_info "Starship already installed"
                track_skipped "$package"
            fi
            ;;
            
        nvm)
            if [[ ! -d "$HOME/.nvm" ]]; then
                print_info "Installing NVM..."
                # Fetch the latest version from GitHub releases
                NVM_LATEST=$(curl -s https://api.github.com/repos/nvm-sh/nvm/releases/latest | grep '"tag_name"' | sed -E 's/.*"([^"]+)".*/\1/')
                if [[ -z "$NVM_LATEST" ]]; then
                    print_warning "Failed to fetch latest NVM version, using fallback"
                    NVM_LATEST="v0.40.1"  # Fallback to a known recent version
                fi
                print_info "Installing NVM version $NVM_LATEST..."
                log_command "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/$NVM_LATEST/install.sh | bash"
                if curl -o- "https://raw.githubusercontent.com/nvm-sh/nvm/$NVM_LATEST/install.sh" 2>/dev/null | bash 2>/dev/null; then
                    log_command "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/$NVM_LATEST/install.sh | bash" "success"
                    track_success "$package"
                    print_success "NVM installed successfully"
                else
                    log_command "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/$NVM_LATEST/install.sh | bash" "failed"
                    track_failure "$package" "Failed to install NVM version $NVM_LATEST"
                    print_error "Failed to install NVM"
                fi
            else
                print_info "NVM already installed"
                track_skipped "$package"
            fi
            ;;
            
        awscli2)
            if ! command -v aws &> /dev/null; then
                print_info "Installing AWS CLI v2..."
                TEMP_DIR=$(mktemp -d)
                (
                    cd "$TEMP_DIR"
                    if curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip" 2>/dev/null && \
                       unzip -q awscliv2.zip && \
                       sudo ./aws/install 2>/dev/null; then
                        track_success "$package"
                        print_success "AWS CLI v2 installed successfully"
                    else
                        track_failure "$package" "Failed to download or install AWS CLI v2"
                        print_error "Failed to install AWS CLI v2"
                    fi
                )
                cd - > /dev/null
                rm -rf "$TEMP_DIR"
            else
                print_info "AWS CLI already installed"
                track_skipped "$package"
            fi
            ;;
            
        azure-cli)
            if ! command -v az &> /dev/null; then
                print_info "Installing Azure CLI..."
                if sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc 2>/dev/null && \
                   echo -e "[azure-cli]\nname=Azure CLI\nbaseurl=https://packages.microsoft.com/yumrepos/azure-cli\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" | sudo tee /etc/yum.repos.d/azure-cli.repo > /dev/null && \
                   sudo dnf install -y azure-cli 2>/dev/null; then
                    track_success "$package"
                    print_success "Azure CLI installed successfully"
                else
                    track_failure "$package" "Failed to configure repository or install Azure CLI"
                    print_error "Failed to install Azure CLI"
                fi
            else
                print_info "Azure CLI already installed"
                track_skipped "$package"
            fi
            ;;
            
        code)
            if ! command -v code &> /dev/null; then
                print_info "Installing Visual Studio Code..."
                if sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc 2>/dev/null && \
                   echo -e "[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc" | sudo tee /etc/yum.repos.d/vscode.repo > /dev/null && \
                   sudo dnf install -y code 2>/dev/null; then
                    track_success "$package"
                    print_success "VS Code installed successfully"
                else
                    track_failure "$package" "Failed to configure repository or install VS Code"
                    print_error "Failed to install VS Code"
                fi
            else
                print_info "VS Code already installed"
                track_skipped "$package"
            fi
            ;;
            
        eza)
            if ! command -v eza &> /dev/null; then
                print_info "Installing eza from source using cargo..."
                
                # Ensure cargo is installed
                if ! command -v cargo &> /dev/null; then
                    track_failure "$package" "Cargo is required but not installed"
                    print_error "Cargo is required to build eza. Please install rust/cargo first."
                else
                    # Create local bin directory if it doesn't exist
                    mkdir -p "$HOME/.local/bin"
                    
                    # Build and install eza
                    TEMP_DIR=$(mktemp -d)
                    (
                        cd "$TEMP_DIR"
                        if git clone https://github.com/eza-community/eza.git 2>/dev/null && \
                           cd eza && \
                           cargo build --release 2>/dev/null && \
                           cp target/release/eza "$HOME/.local/bin/" && \
                           chmod +x "$HOME/.local/bin/eza"; then
                            track_success "$package"
                            print_success "eza installed successfully to ~/.local/bin/"
                            print_info "Make sure ~/.local/bin is in your PATH"
                        else
                            track_failure "$package" "Failed to build or install eza"
                            print_error "Failed to install eza"
                        fi
                    )
                    cd - > /dev/null
                    rm -rf "$TEMP_DIR"
                fi
            else
                print_info "eza already installed"
                track_skipped "$package"
            fi
            ;;
            
        xh)
            if ! command -v xh &> /dev/null; then
                print_info "Installing xh HTTP client..."
                
                # Create local bin directory if it doesn't exist
                mkdir -p "$HOME/.local/bin"
                
                # Detect architecture
                ARCH=$(uname -m)
                case "$ARCH" in
                    x86_64)
                        XH_ARCH="x86_64-unknown-linux-musl"
                        ;;
                    aarch64)
                        XH_ARCH="aarch64-unknown-linux-musl"
                        ;;
                    *)
                        track_failure "$package" "Unsupported architecture: $ARCH"
                        print_error "Unsupported architecture: $ARCH"
                        return 0
                        ;;
                esac
                
                # Download latest release
                TEMP_DIR=$(mktemp -d)
                (
                    cd "$TEMP_DIR"
                    
                    # Get latest version
                    LATEST_VERSION=$(curl -s https://api.github.com/repos/ducaale/xh/releases/latest | grep '"tag_name":' | sed -E 's/.*"v([^"]+)".*/\1/')
                    
                    if [[ -z "$LATEST_VERSION" ]]; then
                        track_failure "$package" "Failed to determine latest xh version"
                        print_error "Failed to determine latest xh version"
                    else
                        print_info "Downloading xh v${LATEST_VERSION}..."
                        if curl -L -o xh.tar.gz "https://github.com/ducaale/xh/releases/download/v${LATEST_VERSION}/xh-v${LATEST_VERSION}-${XH_ARCH}.tar.gz" 2>/dev/null && \
                           tar -xzf xh.tar.gz 2>/dev/null && \
                           cp "xh-v${LATEST_VERSION}-${XH_ARCH}/xh" "$HOME/.local/bin/" && \
                           chmod +x "$HOME/.local/bin/xh" && \
                           ln -sf "$HOME/.local/bin/xh" "$HOME/.local/bin/xhs"; then
                            track_success "$package"
                            print_success "xh installed successfully to ~/.local/bin/"
                            print_info "Make sure ~/.local/bin is in your PATH"
                        else
                            track_failure "$package" "Failed to download or install xh"
                            print_error "Failed to install xh"
                        fi
                    fi
                )
                cd - > /dev/null
                rm -rf "$TEMP_DIR"
            else
                print_info "xh already installed"
                track_skipped "$package"
            fi
            ;;
            
        brave-browser)
            if ! command -v brave-browser &> /dev/null; then
                print_info "Installing Brave Browser..."
                # Download repo file directly (compatible with DNF4 and DNF5)
                if sudo curl -fsSL https://brave-browser-rpm-release.s3.brave.com/brave-browser.repo -o /etc/yum.repos.d/brave-browser.repo 2>/dev/null && \
                   sudo rpm --import https://brave-browser-rpm-release.s3.brave.com/brave-core.asc 2>/dev/null && \
                   sudo dnf install -y brave-browser 2>/dev/null; then
                    track_success "$package"
                    print_success "Brave Browser installed successfully"
                else
                    track_failure "$package" "Failed to configure repository or install Brave Browser"
                    print_error "Failed to install Brave Browser"
                    # Provide more detailed error information
                    if [[ ! -f /etc/yum.repos.d/brave-browser.repo ]]; then
                        print_error "Failed to download Brave repository file"
                    elif ! rpm -q gpg-pubkey-$(sudo rpm -q --qf "%{version}-%{release}\n" gpg-pubkey | grep -i brave 2>/dev/null) &>/dev/null; then
                        print_error "Failed to import Brave GPG key"
                    else
                        print_error "Failed to install brave-browser package from repository"
                    fi
                fi
            else
                print_info "Brave Browser already installed"
                track_skipped "$package"
            fi
            ;;
            
        *)
            track_failure "$package" "Unknown special package"
            print_warning "Unknown special package: $package"
            ;;
    esac
}

# Install dotfiles
install_dotfiles() {
    print_info "Setting up dotfiles..."
    
    if [[ ! -d "$DOTFILES_DIR" ]]; then
        print_info "Cloning dotfiles repository..."
        log_command "git clone $DOTFILES_REPO $DOTFILES_DIR"
        if git clone "$DOTFILES_REPO" "$DOTFILES_DIR" 2>/dev/null; then
            log_command "git clone $DOTFILES_REPO $DOTFILES_DIR" "success"
            print_success "Dotfiles repository cloned successfully"
        else
            log_command "git clone $DOTFILES_REPO $DOTFILES_DIR" "failed"
            track_failure "dotfiles" "Failed to clone repository"
            print_error "Failed to clone dotfiles repository"
            return 0
        fi
    else
        print_info "Updating dotfiles repository..."
        (
            cd "$DOTFILES_DIR"
            log_command "git pull (in $DOTFILES_DIR)"
            if git pull 2>/dev/null; then
                log_command "git pull (in $DOTFILES_DIR)" "success"
                print_success "Dotfiles repository updated successfully"
            else
                log_command "git pull (in $DOTFILES_DIR)" "failed"
                print_warning "Failed to update dotfiles repository"
            fi
        )
    fi
    
    # Run dotfiles installation
    if [[ -f "$DOTFILES_DIR/Makefile" ]]; then
        print_info "Running dotfiles installation..."
        (
            cd "$DOTFILES_DIR"
            if make install 2>/dev/null; then
                track_success "dotfiles"
                print_success "Dotfiles installed successfully"
            else
                track_failure "dotfiles" "Make install failed"
                print_error "Failed to run dotfiles installation"
            fi
        )
    fi
    
    if command -v dotfiles &> /dev/null; then
        if dotfiles install 2>/dev/null; then
            print_success "Dotfiles command executed successfully"
        else
            print_warning "Dotfiles command failed"
        fi
    fi
}

# Install utilities
install_utilities() {
    print_info "Setting up personal utilities..."
    
    if [[ ! -d "$UTILITIES_DIR" ]]; then
        print_info "Cloning utilities repository..."
        if git clone "$UTILITIES_REPO" "$UTILITIES_DIR" 2>/dev/null; then
            print_success "Utilities repository cloned successfully"
        else
            track_failure "utilities" "Failed to clone repository"
            print_error "Failed to clone utilities repository"
            return 0
        fi
    else
        print_info "Updating utilities repository..."
        (
            cd "$UTILITIES_DIR"
            if git pull 2>/dev/null; then
                print_success "Utilities repository updated successfully"
            else
                print_warning "Failed to update utilities repository"
            fi
        )
    fi
    
    # Run utilities installation
    if [[ -f "$UTILITIES_DIR/Makefile" ]]; then
        print_info "Running utilities installation..."
        (
            cd "$UTILITIES_DIR"
            if make install 2>/dev/null; then
                track_success "utilities"
                print_success "Utilities installed successfully"
            else
                track_failure "utilities" "Make install failed"
                print_error "Failed to run utilities installation"
            fi
        )
    else
        print_warning "No Makefile found in utilities repository"
    fi
}

# Save state
save_state() {
    mkdir -p "$STATE_DIR"
    echo "last_install=$(date -Iseconds)" > "$STATE_FILE"
    echo "version=2.0.0" >> "$STATE_FILE"
}

# Load state
load_state() {
    if [[ -f "$STATE_FILE" ]]; then
        source "$STATE_FILE"
        return 0
    fi
    return 1
}

# Install command
cmd_install() {
    check_system
    
    # Reset tracking arrays
    SUCCESSFUL_INSTALLS=()
    FAILED_INSTALLS=()
    SKIPPED_INSTALLS=()
    
    print_info "Starting Pactopus installation..."
    
    # Update system first
    print_info "Updating package database..."
    log_command "sudo dnf check-update"
    sudo dnf check-update || true
    log_command "sudo dnf check-update" "completed"
    
    # Parse packages
    IFS=$'\n' read -d '' -r -a package_data < <(get_packages && printf '\0')
    
    for line in "${package_data[@]}"; do
        if [[ "$line" =~ ^REGULAR:(.*)$ ]]; then
            regular_packages="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^SPECIAL:(.*)$ ]]; then
            special_packages="${BASH_REMATCH[1]}"
        fi
    done
    
    # Install ALL dnf packages first (regular and GNOME) to ensure dependencies are met
    
    # Install regular packages
    if [[ -n "$regular_packages" ]]; then
        print_info "Installing packages via dnf..."
        # Convert space-separated list to array
        IFS=' ' read -ra pkgs <<< "$regular_packages"
        
        # Process each package individually
        for pkg in "${pkgs[@]}"; do
            if ! rpm -q "$pkg" &>/dev/null; then
                print_info "Installing $pkg..."
                log_command "sudo dnf install -y $pkg"
                if sudo dnf install -y "$pkg" 2>/dev/null; then
                    log_command "sudo dnf install -y $pkg" "success"
                    track_success "$pkg"
                    print_success "$pkg installed successfully"
                else
                    log_command "sudo dnf install -y $pkg" "failed"
                    track_failure "$pkg" "DNF installation failed"
                    print_error "Failed to install $pkg"
                fi
            else
                print_info "$pkg is already installed"
                track_skipped "$pkg"
            fi
        done
    fi
    
    # Install GNOME regular packages if in GNOME environment
    if is_gnome_environment; then
        print_info "GNOME desktop detected. Installing GNOME-specific packages..."
        log_entry "INFO" "GNOME environment detected - processing GNOME packages"
        
        # Parse GNOME packages
        IFS=$'\n' read -d '' -r -a gnome_package_data < <(get_gnome_packages && printf '\0')
        
        for line in "${gnome_package_data[@]}"; do
            if [[ "$line" =~ ^REGULAR:(.*)$ ]]; then
                gnome_regular_packages="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^SPECIAL:(.*)$ ]]; then
                gnome_special_packages="${BASH_REMATCH[1]}"
            fi
        done
        
        # Install regular GNOME packages
        if [[ -n "$gnome_regular_packages" ]]; then
            IFS=' ' read -ra gnome_pkgs <<< "$gnome_regular_packages"
            
            for pkg in "${gnome_pkgs[@]}"; do
                if ! rpm -q "$pkg" &>/dev/null; then
                    print_info "Installing GNOME package $pkg..."
                    log_command "sudo dnf install -y $pkg"
                    if sudo dnf install -y "$pkg" 2>/dev/null; then
                        log_command "sudo dnf install -y $pkg" "success"
                        track_success "$pkg"
                        print_success "$pkg installed successfully"
                    else
                        log_command "sudo dnf install -y $pkg" "failed"
                        track_failure "$pkg" "DNF installation failed"
                        print_error "Failed to install $pkg"
                    fi
                else
                    print_info "$pkg is already installed"
                    track_skipped "$pkg"
                fi
            done
        fi
    else
        print_info "GNOME desktop not detected. Skipping GNOME-specific packages."
    fi
    
    # Now install special packages after all dnf packages are installed
    if [[ -n "$special_packages" ]]; then
        print_info "Installing special packages..."
        IFS=' ' read -ra special_pkgs <<< "$special_packages"
        for pkg in "${special_pkgs[@]}"; do
            install_special_package "$pkg"
        done
    fi
    
    # Install special GNOME packages if in GNOME environment
    if is_gnome_environment && [[ -n "$gnome_special_packages" ]]; then
        print_info "Installing special GNOME packages..."
        IFS=' ' read -ra gnome_special_pkgs <<< "$gnome_special_packages"
        for pkg in "${gnome_special_pkgs[@]}"; do
            install_special_package "$pkg"
        done
    fi
    
    # Install GNOME extensions if in GNOME environment
    if is_gnome_environment; then
        install_gnome_extensions
    fi
    
    # Install dotfiles
    install_dotfiles
    
    # Install utilities
    install_utilities
    
    # Save state
    save_state
    
    # Print summary
    print_summary
    
    # Run full system update
    echo ""
    print_info "Running full system update to ensure all packages are up to date..."
    log_command "sudo dnf upgrade -y"
    if sudo dnf upgrade -y 2>/dev/null; then
        log_command "sudo dnf upgrade -y" "success"
        print_success "System update completed successfully"
    else
        log_command "sudo dnf upgrade -y" "failed"
        print_warning "System update encountered issues - please review any errors above"
    fi
    
    # Check if kernel was updated
    KERNEL_UPDATED=false
    if sudo dnf history info last | grep -q "kernel\|kernel-core\|kernel-modules" 2>/dev/null; then
        KERNEL_UPDATED=true
    fi
    
    # Prompt for reboot
    echo ""
    if [[ "$KERNEL_UPDATED" == "true" ]]; then
        print_warning "Kernel updates were installed. A reboot is required to use the new kernel."
    else
        print_info "Installation complete. A reboot is recommended to ensure all updates are applied."
    fi
    
    echo ""
    read -p "Would you like to reboot now? (y/N): " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        print_info "Rebooting system in 5 seconds..."
        print_info "Press Ctrl+C to cancel"
        sleep 5
        sudo systemctl reboot
    else
        print_info "Reboot skipped. Please remember to reboot at your convenience."
        if [[ "$KERNEL_UPDATED" == "true" ]]; then
            print_warning "Note: System is still running the old kernel until you reboot."
        fi
    fi
}

# Update command
cmd_update() {
    check_system
    
    # Reset tracking arrays for update
    SUCCESSFUL_INSTALLS=()
    FAILED_INSTALLS=()
    SKIPPED_INSTALLS=()
    
    print_info "Updating all packages..."
    log_command "sudo dnf upgrade -y"
    sudo dnf upgrade -y
    log_command "sudo dnf upgrade -y" "completed"
    
    # Re-run package installation to catch any missing packages
    print_info "Checking for missing packages..."
    
    # Parse regular packages
    IFS=$'\n' read -d '' -r -a package_data < <(get_packages && printf '\0')
    
    for line in "${package_data[@]}"; do
        if [[ "$line" =~ ^REGULAR:(.*)$ ]]; then
            regular_packages="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^SPECIAL:(.*)$ ]]; then
            special_packages="${BASH_REMATCH[1]}"
        fi
    done
    
    # Install ALL dnf packages first (regular and GNOME) to ensure dependencies are met
    
    # Check and install missing regular packages
    if [[ -n "$regular_packages" ]]; then
        IFS=' ' read -ra pkgs <<< "$regular_packages"
        for pkg in "${pkgs[@]}"; do
            if ! rpm -q "$pkg" &>/dev/null; then
                print_info "Installing missing package $pkg..."
                log_command "sudo dnf install -y $pkg"
                if sudo dnf install -y "$pkg" 2>/dev/null; then
                    log_command "sudo dnf install -y $pkg" "success"
                    track_success "$pkg"
                    print_success "$pkg installed successfully"
                else
                    log_command "sudo dnf install -y $pkg" "failed"
                    track_failure "$pkg" "DNF installation failed"
                    print_error "Failed to install $pkg"
                fi
            fi
        done
    fi
    
    # Check GNOME regular packages if in GNOME environment
    if is_gnome_environment; then
        print_info "Checking for missing GNOME packages..."
        
        # Parse GNOME packages
        IFS=$'\n' read -d '' -r -a gnome_package_data < <(get_gnome_packages && printf '\0')
        
        for line in "${gnome_package_data[@]}"; do
            if [[ "$line" =~ ^REGULAR:(.*)$ ]]; then
                gnome_regular_packages="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^SPECIAL:(.*)$ ]]; then
                gnome_special_packages="${BASH_REMATCH[1]}"
            fi
        done
        
        # Check and install missing GNOME packages
        if [[ -n "$gnome_regular_packages" ]]; then
            IFS=' ' read -ra gnome_pkgs <<< "$gnome_regular_packages"
            for pkg in "${gnome_pkgs[@]}"; do
                if ! rpm -q "$pkg" &>/dev/null; then
                    print_info "Installing missing GNOME package $pkg..."
                    log_command "sudo dnf install -y $pkg"
                    if sudo dnf install -y "$pkg" 2>/dev/null; then
                        log_command "sudo dnf install -y $pkg" "success"
                        track_success "$pkg"
                        print_success "$pkg installed successfully"
                    else
                        log_command "sudo dnf install -y $pkg" "failed"
                        track_failure "$pkg" "DNF installation failed"
                        print_error "Failed to install $pkg"
                    fi
                fi
            done
        fi
    fi
    
    # Now re-install special packages after all dnf packages are installed
    if [[ -n "$special_packages" ]]; then
        IFS=' ' read -ra special_pkgs <<< "$special_packages"
        for pkg in "${special_pkgs[@]}"; do
            install_special_package "$pkg"
        done
    fi
    
    # Re-install special GNOME packages if in GNOME environment
    if is_gnome_environment && [[ -n "$gnome_special_packages" ]]; then
        IFS=' ' read -ra gnome_special_pkgs <<< "$gnome_special_packages"
        for pkg in "${gnome_special_pkgs[@]}"; do
            install_special_package "$pkg"
        done
    fi
    
    # Update GNOME extensions if in GNOME environment
    if is_gnome_environment; then
        install_gnome_extensions
    fi
    
    # Update dotfiles
    install_dotfiles
    
    # Update utilities
    install_utilities
    
    # Update state
    save_state
    
    # Print summary
    print_summary
}

# Status command
cmd_status() {
    if load_state; then
        print_info "Pactopus Status:"
        echo "  Last install: ${last_install:-unknown}"
        echo "  Version: ${version:-unknown}"
        echo "  Config file: $CONFIG_FILE"
        echo "  State file: $STATE_FILE"
    else
        print_warning "No installation state found. Run 'pactopus install' first."
    fi
}

# List command
cmd_list() {
    print_info "Available packages in $CONFIG_FILE:"
    echo ""
    
    # Parse and display packages
    IFS=$'\n' read -d '' -r -a package_data < <(get_packages && printf '\0')
    
    for line in "${package_data[@]}"; do
        if [[ "$line" =~ ^REGULAR:(.*)$ ]]; then
            regular_packages="${BASH_REMATCH[1]}"
        elif [[ "$line" =~ ^SPECIAL:(.*)$ ]]; then
            special_packages="${BASH_REMATCH[1]}"
        fi
    done
    
    echo "Standard packages (installed via dnf):"
    IFS=' ' read -ra pkgs <<< "$regular_packages"
    for pkg in "${pkgs[@]}"; do
        if rpm -q "$pkg" &>/dev/null; then
            echo "  ✓ $pkg"
        else
            echo "    $pkg"
        fi
    done
    
    echo ""
    echo "Special packages (custom installation):"
    IFS=' ' read -ra special_pkgs <<< "$special_packages"
    for pkg in "${special_pkgs[@]}"; do
        # Check if special package is installed
        case "$pkg" in
            starship) cmd="starship" ;;
            nvm) [[ -d "$HOME/.nvm" ]] && echo "  ✓ $pkg" || echo "    $pkg"; continue ;;
            awscli2) cmd="aws" ;;
            azure-cli) cmd="az" ;;
            code) cmd="code" ;;
            eza) cmd="eza" ;;
            xh) cmd="xh" ;;
            brave-browser) cmd="brave-browser" ;;
            gnome-shell-extension-pop-shell) 
                [[ -d "$HOME/.local/share/gnome-shell/extensions/pop-shell@system76.com" ]] && echo "  ✓ $pkg" || echo "    $pkg"
                continue ;;
            *) cmd="$pkg" ;;
        esac
        
        if command -v "$cmd" &>/dev/null; then
            echo "  ✓ $pkg"
        else
            echo "    $pkg"
        fi
    done
    
    # Show GNOME packages if in GNOME environment
    if is_gnome_environment; then
        echo ""
        print_info "GNOME Desktop packages from $GNOME_CONFIG_FILE:"
        echo ""
        
        # Parse GNOME packages
        IFS=$'\n' read -d '' -r -a gnome_package_data < <(get_gnome_packages && printf '\0')
        
        for line in "${gnome_package_data[@]}"; do
            if [[ "$line" =~ ^REGULAR:(.*)$ ]]; then
                gnome_regular_packages="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^SPECIAL:(.*)$ ]]; then
                gnome_special_packages="${BASH_REMATCH[1]}"
            fi
        done
        
        if [[ -n "$gnome_regular_packages" ]]; then
            echo "GNOME packages (installed via dnf):"
            IFS=' ' read -ra gnome_pkgs <<< "$gnome_regular_packages"
            for pkg in "${gnome_pkgs[@]}"; do
                if rpm -q "$pkg" &>/dev/null; then
                    echo "  ✓ $pkg"
                else
                    echo "    $pkg"
                fi
            done
        fi
        
        if [[ -n "$gnome_special_packages" ]]; then
            echo ""
            echo "GNOME special packages (custom installation):"
            IFS=' ' read -ra gnome_special_pkgs <<< "$gnome_special_packages"
            for pkg in "${gnome_special_pkgs[@]}"; do
                case "$pkg" in
                    gnome-shell-extension-pop-shell) 
                        [[ -d "$HOME/.local/share/gnome-shell/extensions/pop-shell@system76.com" ]] && echo "  ✓ $pkg" || echo "    $pkg"
                        ;;
                    *)
                        echo "    $pkg"
                        ;;
                esac
            done
        fi
    fi
}

# Help command
cmd_help() {
    cat << EOF
Pactopus - Simple Package Manager for Fedora
Version 2.0.0

Usage: pactopus [command]

Commands:
  install    Install all packages from packages.conf
  update     Update all installed packages
  list       List all available packages
  status     Show installation status
  help       Show this help message
  version    Show version information

Configuration:
  Package list: $CONFIG_FILE
  State directory: $STATE_DIR

Examples:
  pactopus install    # Install all packages
  pactopus update     # Update packages
  pactopus list       # Show available packages
  pactopus status     # Check installation status

EOF
}

# Version command
cmd_version() {
    echo "Pactopus version 2.0.0"
}

# Main script
main() {
    # Initialize logging
    init_logging "$@"
    
    case "${1:-help}" in
        install)
            cmd_install
            ;;
        update)
            cmd_update
            ;;
        list)
            cmd_list
            ;;
        status)
            cmd_status
            ;;
        version)
            cmd_version
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            print_error "Unknown command: $1"
            cmd_help
            log_entry "INFO" "Pactopus session ended with error - unknown command"
            exit 1
            ;;
    esac
    
    # Log session end
    log_entry "INFO" "Pactopus session ended successfully"
}

main "$@"
