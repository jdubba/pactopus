#!/usr/bin/env bash

# Pactopus - Cross-distribution personal package management DSC tool
# Version: 0.1.3

set -euo pipefail

# Global variables
readonly PACTOPUS_VERSION="0.1.3"
readonly SCRIPT_NAME=$(basename "$0")
readonly MIN_ANSIBLE_VERSION="2.10"
readonly MIN_ANSIBLE_COMMUNITY_VERSION="8.0.0"

# Configuration
readonly CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/pactopus"
readonly CONFIG_FILE="${CONFIG_DIR}/pactopus.toml"

# Configuration variables (with defaults)
declare -g SOURCE_INSTALL_LOCATION="$HOME/source"

# OS Detection variables
declare -g OS_ID=""
declare -g OS_VERSION=""
declare -g OS_FAMILY=""

# Initialize default configuration file
init_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        echo "Creating configuration directory: $CONFIG_DIR"
        mkdir -p "$CONFIG_DIR"
    fi
    
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "Creating default configuration file: $CONFIG_FILE"
        cat > "$CONFIG_FILE" << 'EOF'
# Pactopus Configuration File
# This file uses TOML format for configuration settings

[settings]
# Source installation location for development tools and projects
# Default: ~/source
SOURCE_INSTALL_LOCATION = "~/source"

[package_sets]
# Future: Define custom package sets here
# minimal = ["git", "curl", "make"]
# development = ["git", "curl", "make", "stow", "fzf", "bat", "ripgrep"]

[repositories]
# Future: Custom repository configurations
# enable_backports = true
# enable_epel = true
EOF
        echo "Default configuration created at $CONFIG_FILE"
    fi
}

# Load configuration from TOML file
load_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        init_config
    fi
    
    # Simple TOML parser for our specific needs
    # This handles basic key = "value" pairs in [settings] section
    local in_settings_section=false
    
    while IFS= read -r line; do
        # Remove leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^# ]] && continue
        
        # Check for section headers
        if [[ "$line" =~ ^\[.*\]$ ]]; then
            if [[ "$line" == "[settings]" ]]; then
                in_settings_section=true
            else
                in_settings_section=false
            fi
            continue
        fi
        
        # Process settings if we're in the [settings] section
        if [[ "$in_settings_section" == true && "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*[[:space:]]*=[[:space:]]*\".*\"$ ]]; then
            # Extract key and value
            local key=$(echo "$line" | sed 's/[[:space:]]*=.*//')
            local value=$(echo "$line" | sed 's/.*=[[:space:]]*"\(.*\)".*/\1/')
            
            # Expand tilde in paths
            if [[ "$value" =~ ^\~.* ]]; then
                value="${value/#\~/$HOME}"
            fi
            
            # Set the corresponding variable
            case "$key" in
                "SOURCE_INSTALL_LOCATION")
                    SOURCE_INSTALL_LOCATION="$value"
                    ;;
                *)
                    echo "Warning: Unknown configuration key '$key' in $CONFIG_FILE" >&2
                    ;;
            esac
        fi
    done < "$CONFIG_FILE"
}

# Display current configuration
show_config() {
    echo "Pactopus Configuration"
    echo "======================"
    echo "Configuration file: $CONFIG_FILE"
    echo ""
    echo "Settings:"
    echo "  SOURCE_INSTALL_LOCATION = \"$SOURCE_INSTALL_LOCATION\""
    echo ""
    echo "To modify configuration, edit: $CONFIG_FILE"
}

# Detect the current operating system
detect_os() {
    if [[ -f /etc/os-release ]]; then
        # shellcheck source=/dev/null
        source /etc/os-release
        OS_ID="${ID,,}"
        OS_VERSION="${VERSION_ID:-}"
        
        # Determine OS family based on ID
        case "$OS_ID" in
            ubuntu|debian|linuxmint|pop|elementary)
                OS_FAMILY="debian"
                ;;
            fedora|centos|rhel|almalinux|rocky|amazonlinux)
                OS_FAMILY="redhat"
                ;;
            arch|manjaro|endeavouros)
                OS_FAMILY="arch"
                ;;
            opensuse*|suse|sles)
                OS_FAMILY="suse"
                ;;
            alpine)
                OS_FAMILY="alpine"
                ;;
            *)
                OS_FAMILY="unknown"
                ;;
        esac
    else
        echo "Error: Cannot detect operating system" >&2
        exit 1
    fi
}

# Compare two version strings (returns 0 if v1 >= v2, 1 otherwise)
version_compare() {
    local v1="$1"
    local v2="$2"
    
    # Convert versions to comparable format
    local v1_norm v2_norm
    v1_norm=$(echo "$v1" | sed 's/[^0-9.]*//g')
    v2_norm=$(echo "$v2" | sed 's/[^0-9.]*//g')
    
    # Use sort -V to compare versions
    if [[ "$v1_norm" == "$(printf '%s\n%s' "$v1_norm" "$v2_norm" | sort -V | tail -n1)" ]]; then
        return 0
    else
        return 1
    fi
}

# Check if pipx is installed and install if needed
ensure_pipx() {
    if command -v pipx >/dev/null 2>&1; then
        echo "pipx is already installed"
        return 0
    fi
    
    echo "Installing pipx..."
    
    case "$OS_FAMILY" in
        debian)
            # Install python3-pip and python3-venv if not present
            if ! command -v pip3 >/dev/null 2>&1; then
                echo "Installing python3-pip and dependencies..."
                sudo apt-get update
                sudo apt-get install -y python3-pip python3-venv python3-dev
            fi
            
            # Try to install pipx via apt first (newer Ubuntu/Debian)
            if sudo apt-get install -y pipx 2>/dev/null; then
                echo "pipx installed via apt"
            else
                echo "Installing pipx via pip..."
                pip3 install --user pipx
            fi
            ;;
            
        redhat)
            # Install python3-pip if not present
            if ! command -v pip3 >/dev/null 2>&1; then
                if [[ "$OS_ID" == "fedora" ]]; then
                    sudo dnf install -y python3-pip python3-devel
                else
                    sudo dnf install -y epel-release
                    sudo dnf install -y python3-pip python3-devel
                fi
            fi
            
            # Try to install pipx via package manager first
            if [[ "$OS_ID" == "fedora" ]] && sudo dnf install -y pipx 2>/dev/null; then
                echo "pipx installed via dnf"
            else
                echo "Installing pipx via pip..."
                pip3 install --user pipx
            fi
            ;;
            
        arch)
            # Install pipx via pacman
            sudo pacman -Sy --noconfirm python-pipx
            ;;
            
        suse)
            # Install python3-pip if not present
            if ! command -v pip3 >/dev/null 2>&1; then
                sudo zypper install -y python3-pip python3-devel
            fi
            echo "Installing pipx via pip..."
            pip3 install --user pipx
            ;;
            
        alpine)
            # Install python3-pip if not present
            if ! command -v pip3 >/dev/null 2>&1; then
                sudo apk add python3-dev py3-pip
            fi
            echo "Installing pipx via pip..."
            pip3 install --user pipx
            ;;
            
        *)
            echo "Installing pipx via pip for unknown OS..."
            if ! command -v pip3 >/dev/null 2>&1; then
                echo "Error: pip3 not found. Please install python3-pip first." >&2
                exit 1
            fi
            pip3 install --user pipx
            ;;
    esac
    
    # Ensure pipx is in PATH
    if ! command -v pipx >/dev/null 2>&1; then
        # Add ~/.local/bin to PATH for current session
        export PATH="$HOME/.local/bin:$PATH"
        
        if ! command -v pipx >/dev/null 2>&1; then
            echo "Error: pipx installation failed or not in PATH" >&2
            echo "Please ensure ~/.local/bin is in your PATH" >&2
            exit 1
        fi
    fi
    
    # Initialize pipx
    pipx ensurepath
    echo "pipx installation complete"
}

# Check if ansible is installed and get version
check_ansible() {
    local ansible_ok=true
    local ansible_community_ok=true
    
    # Check ansible core
    if command -v ansible >/dev/null 2>&1; then
        local ansible_version
        ansible_version=$(ansible --version 2>/dev/null | head -n1 | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n1)
        
        if [[ -n "$ansible_version" ]]; then
            echo "Found ansible version: $ansible_version"
            if version_compare "$ansible_version" "$MIN_ANSIBLE_VERSION"; then
                echo "Ansible core version is acceptable"
            else
                echo "Ansible version $ansible_version is below minimum required version $MIN_ANSIBLE_VERSION"
                ansible_ok=false
            fi
        else
            echo "Could not determine ansible version"
            ansible_ok=false
        fi
    else
        echo "Ansible is not installed"
        ansible_ok=false
    fi
    
    # Check ansible-community collections
    if command -v ansible-galaxy >/dev/null 2>&1; then
        # Try to get community collection version
        local community_version
        community_version=$(ansible-galaxy collection list community.general 2>/dev/null | grep -E '^community\.general' | awk '{print $2}' | head -n1)
        
        if [[ -n "$community_version" ]]; then
            echo "Found ansible community.general version: $community_version"
            if version_compare "$community_version" "$MIN_ANSIBLE_COMMUNITY_VERSION"; then
                echo "Ansible community collections are up to date"
            else
                echo "Ansible community version $community_version is below minimum required version $MIN_ANSIBLE_COMMUNITY_VERSION"
                ansible_community_ok=false
            fi
        else
            echo "Ansible community collections not found"
            ansible_community_ok=false
        fi
    else
        echo "ansible-galaxy not available"
        ansible_community_ok=false
    fi
    
    # Return success only if both are OK
    if $ansible_ok && $ansible_community_ok; then
        return 0
    else
        return 1
    fi
}

# Install ansible and ansible-community via pipx
install_ansible() {
    echo "Installing ansible via pipx..."
    
    # Ensure pipx is installed first
    ensure_pipx
    
    # Install ansible core via pipx
    echo "Installing ansible core..."
    if pipx list | grep -q "ansible "; then
        echo "Upgrading existing ansible installation..."
        pipx upgrade ansible
    else
        pipx install ansible
    fi
    
    # Install ansible community collections
    echo "Installing ansible community collections..."
    if command -v ansible-galaxy >/dev/null 2>&1; then
        # Install community collections
        ansible-galaxy collection install community.general --upgrade
        ansible-galaxy collection install community.crypto --upgrade
        ansible-galaxy collection install ansible.posix --upgrade
    else
        echo "Warning: ansible-galaxy not available, community collections may not be installed"
    fi
    
    # Verify installation
    if command -v ansible >/dev/null 2>&1; then
        echo "Ansible installation successful!"
        ansible --version
        echo ""
        echo "Installed collections:"
        ansible-galaxy collection list 2>/dev/null | head -10 || echo "Could not list collections"
    else
        echo "Error: Ansible installation failed" >&2
        exit 1
    fi
}

# Setup ansible environment and dependencies
setup_ansible() {
    echo "Setting up ansible environment..."
    
    # Detect OS first
    detect_os
    echo "Detected OS: $OS_ID ($OS_FAMILY)"
    
    # Check if ansible is already installed and up to date
    if check_ansible; then
        echo "Ansible setup complete"
        return 0
    fi
    
    # Install ansible
    install_ansible
    
    # Verify final installation
    if ! check_ansible; then
        echo "Error: Ansible setup failed" >&2
        exit 1
    fi
    
    echo "Ansible setup complete!"
}

# Print version information
version() {
    echo "pactopus version ${PACTOPUS_VERSION}"
}

# Validate sudo access and cache credentials
validate_sudo_access() {
    echo "Validating sudo access for package management..."
    
    # Test if we already have sudo access (cached)
    if sudo -n true 2>/dev/null; then
        echo "Sudo access already available"
        return 0
    fi
    
    # Test sudo access and cache credentials
    if sudo -v; then
        echo "Sudo access validated and credentials cached"
        return 0
    else
        echo "Error: Failed to validate sudo access" >&2
        echo "Note: Some packages may not require sudo and could still work" >&2
        return 1
    fi
}

# Run ansible playbook for package management
run_ansible_playbook() {
    local action="$1"
    shift
    local packages=("$@")
    
    if [[ ${#packages[@]} -eq 0 ]]; then
        echo "Error: No packages specified" >&2
        return 1
    fi
    
    # Determine playbook directory location
    local playbook_dir
    local inventory_path
    
    # First try the installed location
    if [[ -d "$HOME/.local/share/pactopus/playbooks" ]]; then
        playbook_dir="$HOME/.local/share/pactopus/playbooks"
        inventory_path="${playbook_dir}/inventory"
    else
        # Fallback to development location
        local script_dir="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
        playbook_dir="${script_dir}/playbooks"
        inventory_path="${playbook_dir}/inventory"
    fi
    
    # Ensure ansible is available
    if ! command -v ansible-playbook >/dev/null 2>&1; then
        echo "Error: ansible-playbook not found. Run '${SCRIPT_NAME} setup' first." >&2
        return 1
    fi
    
    # Verify inventory file exists
    if [[ ! -f "$inventory_path" ]]; then
        echo "Error: Ansible inventory not found at: ${inventory_path}" >&2
        return 1
    fi
    
    # Check if any playbooks require sudo access
    local needs_sudo=false
    for package in "${packages[@]}"; do
        local playbook_path="${playbook_dir}/${package}/${action}-${package}.yml"
        if [[ -f "$playbook_path" ]] && grep -q "become: yes" "$playbook_path" 2>/dev/null; then
            needs_sudo=true
            break
        fi
    done
    
    # Validate sudo access only if needed
    if $needs_sudo; then
        if ! validate_sudo_access; then
            echo "Warning: Some playbooks require sudo access but validation failed" >&2
            echo "Continuing anyway - packages that don't need sudo may still work" >&2
        fi
    else
        echo "No sudo access required for selected packages"
    fi
    
    local success_count=0
    local total_count=${#packages[@]}
    
    # Process each package
    for package in "${packages[@]}"; do
        local playbook_path="${playbook_dir}/${package}/${action}-${package}.yml"
        
        if [[ ! -f "$playbook_path" ]]; then
            echo "Error: Playbook not found for package '${package}': ${playbook_path}" >&2
            continue
        fi
        
        echo "Running ${action} playbook for ${package}..."
        
        # Prepare extra variables for ansible
        local extra_vars="source_install_location='$SOURCE_INSTALL_LOCATION'"
        
        # Run the ansible playbook with conditional become flag
        local become_flag=""
        if grep -q "become: yes" "$playbook_path" 2>/dev/null; then
            become_flag="--become"
        fi
        
        if ansible-playbook -i "$inventory_path" "$playbook_path" $become_flag --extra-vars "$extra_vars"; then
            echo "Successfully ${action}ed ${package}"
            ((success_count++)) || true
        else
            echo "Error: Failed to ${action} ${package}" >&2
        fi
        
        # Refresh sudo credentials if we have more packages to process
        if [[ $package != "${packages[-1]}" ]]; then
            # Keep sudo credentials fresh for long-running operations
            sudo -v 2>/dev/null || true
        fi
    done
    
    # Display summary
    echo ""
    echo "Package ${action} summary: ${success_count}/${total_count} successful"
    
    if [[ $success_count -eq $total_count ]]; then
        echo "All packages ${action}ed successfully!"
        return 0
    elif [[ $success_count -gt 0 ]]; then
        echo "Some packages ${action}ed successfully, but some failed."
        return 1
    else
        echo "All package ${action} operations failed."
        return 1
    fi
}

# Install packages using ansible playbooks
install_packages() {
    run_ansible_playbook "install" "$@"
    return $?
}

# Remove packages using ansible playbooks
remove_packages() {
    run_ansible_playbook "remove" "$@"
    return $?
}

# Print help information
help() {
    cat << EOF
Pactopus - Cross-distribution personal package management DSC tool

Usage: ${SCRIPT_NAME} [COMMAND] <OPTIONS> arguments

Commands:
    version      Display the version information
    help         Display this help message
    setup        Setup ansible environment and dependencies
    check        Check system requirements and ansible status
    config       Display current configuration settings
    install      Install one or more packages
    remove       Remove one or more packages

Options:
    -h, --help   Display help information

Configuration:
    Configuration file: ~/.config/pactopus/pactopus.toml
    Settings:
      SOURCE_INSTALL_LOCATION - Directory for source installations (default: ~/source)

Available packages:
    git, gawk, make, stow, fzf, curl, fastfetch, bat, bash-completion, ripgrep, ble, neovim, starship, wget, sudo, which, xh, yai

Examples:
    ${SCRIPT_NAME} version
    ${SCRIPT_NAME} help
    ${SCRIPT_NAME} setup
    ${SCRIPT_NAME} check
    ${SCRIPT_NAME} config
    ${SCRIPT_NAME} install git curl make
    ${SCRIPT_NAME} remove git
    ${SCRIPT_NAME} install bat bash-completion ripgrep

EOF
}

# Main entry point
main() {
    # Load configuration before processing commands
    load_config
    
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        help
        exit 0
    fi

    # Parse command
    local command="${1:-}"
    shift || true

    case "${command}" in
        version)
            version
            ;;
        help|-h|--help)
            help
            ;;
        setup)
            setup_ansible
            ;;
        check)
            detect_os
            echo "OS: $OS_ID ($OS_FAMILY) $OS_VERSION"
            check_ansible
            ;;
        config)
            show_config
            ;;
        install)
            if [[ $# -eq 0 ]]; then
                echo "Error: No packages specified for installation" >&2
                echo "Usage: ${SCRIPT_NAME} install <package1> [package2] ..." >&2
                echo "Available packages: git, gawk, make, stow, fzf, curl, fastfetch, bat, bash-completion, ripgrep, ble, neovim, starship, wget, sudo, which, xh, yai" >&2
                exit 1
            fi
            install_packages "$@"
            exit $?
            ;;
        remove)
            if [[ $# -eq 0 ]]; then
                echo "Error: No packages specified for removal" >&2
                echo "Usage: ${SCRIPT_NAME} remove <package1> [package2] ..." >&2
                echo "Available packages: git, gawk, make, stow, fzf, curl, fastfetch, bat, bash-completion, ripgrep, ble, neovim, starship, wget, sudo, which, xh, yai" >&2
                exit 1
            fi
            remove_packages "$@"
            exit $?
            ;;
        *)
            echo "Error: Unknown command '${command}'" >&2
            echo "Run '${SCRIPT_NAME} help' for usage information." >&2
            exit 1
            ;;
    esac
}

# Run main function
main "$@"